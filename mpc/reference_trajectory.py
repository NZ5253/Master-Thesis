"""
Reference Trajectory Data Structure for Hybrid TEB+MPC

This module defines the data structure for storing reference trajectories
generated by TEB planning, which will be tracked by the MPC controller.

A ReferenceTrajectory encapsulates:
- State trajectory: positions, yaws, velocities at each waypoint
- Control trajectory: steering and acceleration commands
- Timing: dt values for variable-time trajectories (TEB) or constant for fixed-dt
- Metadata: total time, number of steps, success flags
"""

import numpy as np
from dataclasses import dataclass
from typing import Optional, List


@dataclass
class ReferenceTrajectory:
    """
    Reference trajectory for MPC tracking.

    Generated by TEB planner, this trajectory represents the committed plan
    that MPC will track without re-planning. This separation of planning and
    control eliminates oscillations caused by receding horizon re-optimization.

    Attributes:
        states: State trajectory [N x 4] - [x, y, theta, v] at each waypoint
        controls: Control trajectory [N x 2] - [steering, accel] at each step
        dt_array: Time intervals [N] - dt[i] is duration of step i
        total_time: Total trajectory duration in seconds
        n_steps: Number of steps in trajectory
        success: Whether planning succeeded
        metadata: Dictionary for additional info (e.g., costs, iterations)
    """

    states: np.ndarray        # Shape: (N, 4) - [x, y, theta, v]
    controls: np.ndarray      # Shape: (N, 2) - [steering, accel]
    dt_array: np.ndarray      # Shape: (N,) - time intervals
    total_time: float
    n_steps: int
    success: bool
    metadata: Optional[dict] = None

    def __post_init__(self):
        """Validate trajectory consistency."""
        assert self.states.shape[0] == self.n_steps, \
            f"States shape {self.states.shape} doesn't match n_steps={self.n_steps}"
        assert self.controls.shape[0] == self.n_steps, \
            f"Controls shape {self.controls.shape} doesn't match n_steps={self.n_steps}"
        assert self.dt_array.shape[0] == self.n_steps, \
            f"dt_array shape {self.dt_array.shape} doesn't match n_steps={self.n_steps}"
        assert self.states.shape[1] == 4, \
            f"States should have 4 columns [x, y, theta, v], got {self.states.shape[1]}"
        assert self.controls.shape[1] == 2, \
            f"Controls should have 2 columns [steering, accel], got {self.controls.shape[1]}"
        assert np.isclose(self.total_time, np.sum(self.dt_array), atol=1e-3), \
            f"total_time={self.total_time} != sum(dt_array)={np.sum(self.dt_array)}"

    @classmethod
    def from_fixed_dt(cls, states: np.ndarray, controls: np.ndarray, dt: float) -> 'ReferenceTrajectory':
        """
        Create reference trajectory with fixed time step.

        Args:
            states: State trajectory [N x 4]
            controls: Control trajectory [N x 2]
            dt: Fixed time step (e.g., 0.1s)

        Returns:
            ReferenceTrajectory with constant dt values
        """
        n_steps = states.shape[0]
        dt_array = np.full(n_steps, dt)
        total_time = n_steps * dt

        return cls(
            states=states,
            controls=controls,
            dt_array=dt_array,
            total_time=total_time,
            n_steps=n_steps,
            success=True,
            metadata={"type": "fixed_dt", "dt": dt}
        )

    @classmethod
    def from_teb_solution(cls, states: np.ndarray, controls: np.ndarray,
                          dt_array: np.ndarray, metadata: Optional[dict] = None) -> 'ReferenceTrajectory':
        """
        Create reference trajectory from TEB optimization result.

        Args:
            states: State trajectory [N x 4] from TEB
            controls: Control trajectory [N x 2] from TEB
            dt_array: Variable time intervals [N] from TEB
            metadata: Optional dict with TEB solver info

        Returns:
            ReferenceTrajectory with variable dt values
        """
        n_steps = states.shape[0]
        total_time = float(np.sum(dt_array))

        teb_metadata = {"type": "teb", "variable_dt": True}
        if metadata is not None:
            teb_metadata.update(metadata)

        return cls(
            states=states,
            controls=controls,
            dt_array=dt_array,
            total_time=total_time,
            n_steps=n_steps,
            success=True,
            metadata=teb_metadata
        )

    def get_state_at_step(self, step: int) -> np.ndarray:
        """
        Get reference state at specific step.

        Args:
            step: Step index (0 to n_steps-1)

        Returns:
            State vector [x, y, theta, v]
        """
        assert 0 <= step < self.n_steps, f"Step {step} out of range [0, {self.n_steps})"
        return self.states[step]

    def get_control_at_step(self, step: int) -> np.ndarray:
        """
        Get reference control at specific step.

        Args:
            step: Step index (0 to n_steps-1)

        Returns:
            Control vector [steering, accel]
        """
        assert 0 <= step < self.n_steps, f"Step {step} out of range [0, {self.n_steps})"
        return self.controls[step]

    def get_dt_at_step(self, step: int) -> float:
        """
        Get time interval at specific step.

        Args:
            step: Step index (0 to n_steps-1)

        Returns:
            Time interval dt in seconds
        """
        assert 0 <= step < self.n_steps, f"Step {step} out of range [0, {self.n_steps})"
        return float(self.dt_array[step])

    def get_reference_window(self, start_step: int, horizon: int) -> tuple:
        """
        Get reference trajectory window for MPC horizon.

        This is used by the tracking MPC to get the reference trajectory
        for the next N steps from the current position.

        Args:
            start_step: Starting step in reference trajectory
            horizon: MPC horizon length (number of steps to extract)

        Returns:
            Tuple of (states_window, controls_window, dt_window)
            Each has length min(horizon, remaining_steps)
        """
        remaining = self.n_steps - start_step
        window_size = min(horizon, remaining)

        if window_size <= 0:
            # No more reference trajectory available
            return None, None, None

        end_step = start_step + window_size
        states_window = self.states[start_step:end_step]
        controls_window = self.controls[start_step:end_step]
        dt_window = self.dt_array[start_step:end_step]

        return states_window, controls_window, dt_window

    def analyze_maneuvers(self, steering_threshold: float = 0.05) -> List[dict]:
        """
        Analyze reference trajectory to identify committed maneuvers.

        A "committed maneuver" is a sequence of steps with similar steering
        (e.g., full lock right for 1.5s, then straighten for 0.5s).

        Args:
            steering_threshold: Steering change threshold to detect maneuver transitions

        Returns:
            List of maneuvers, each with:
            - start_step: Starting step index
            - end_step: Ending step index (exclusive)
            - duration: Total duration in seconds
            - avg_steering: Average steering angle
            - avg_accel: Average acceleration
            - description: Human-readable description
        """
        maneuvers = []

        if self.n_steps == 0:
            return maneuvers

        # Start first maneuver
        current_maneuver = {
            "start_step": 0,
            "steering_values": [self.controls[0, 0]],
            "accel_values": [self.controls[0, 1]],
            "dt_values": [self.dt_array[0]]
        }

        for step in range(1, self.n_steps):
            steering = self.controls[step, 0]
            accel = self.controls[step, 1]
            dt = self.dt_array[step]

            # Check if steering changed significantly (maneuver transition)
            prev_steering = current_maneuver["steering_values"][-1]
            if abs(steering - prev_steering) > steering_threshold:
                # Finalize current maneuver
                maneuvers.append(self._finalize_maneuver(current_maneuver, step))

                # Start new maneuver
                current_maneuver = {
                    "start_step": step,
                    "steering_values": [steering],
                    "accel_values": [accel],
                    "dt_values": [dt]
                }
            else:
                # Continue current maneuver
                current_maneuver["steering_values"].append(steering)
                current_maneuver["accel_values"].append(accel)
                current_maneuver["dt_values"].append(dt)

        # Finalize last maneuver
        maneuvers.append(self._finalize_maneuver(current_maneuver, self.n_steps))

        return maneuvers

    def _finalize_maneuver(self, maneuver_data: dict, end_step: int) -> dict:
        """Helper to finalize maneuver statistics."""
        avg_steering = np.mean(maneuver_data["steering_values"])
        avg_accel = np.mean(maneuver_data["accel_values"])
        duration = np.sum(maneuver_data["dt_values"])
        n_steps = len(maneuver_data["steering_values"])

        # Generate human-readable description
        if abs(avg_steering) < 0.05:
            steer_desc = "straight"
        elif avg_steering > 0.3:
            steer_desc = "full right"
        elif avg_steering > 0.1:
            steer_desc = "right"
        elif avg_steering < -0.3:
            steer_desc = "full left"
        elif avg_steering < -0.1:
            steer_desc = "left"
        else:
            steer_desc = "slight adjustment"

        description = f"{steer_desc} for {duration:.2f}s ({n_steps} steps)"

        return {
            "start_step": maneuver_data["start_step"],
            "end_step": end_step,
            "duration": duration,
            "n_steps": n_steps,
            "avg_steering": avg_steering,
            "avg_accel": avg_accel,
            "description": description
        }

    def summary(self) -> str:
        """
        Generate human-readable summary of reference trajectory.

        Returns:
            Multi-line string with trajectory statistics
        """
        lines = [
            "Reference Trajectory Summary",
            "=" * 50,
            f"Steps: {self.n_steps}",
            f"Duration: {self.total_time:.2f}s",
            f"Success: {self.success}",
            f"Type: {self.metadata.get('type', 'unknown') if self.metadata else 'unknown'}",
            ""
        ]

        # Analyze maneuvers
        maneuvers = self.analyze_maneuvers()
        lines.append(f"Committed Maneuvers: {len(maneuvers)}")
        lines.append("-" * 50)
        for i, m in enumerate(maneuvers):
            lines.append(f"{i+1}. Steps {m['start_step']:3d}-{m['end_step']:3d}: {m['description']}")

        return "\n".join(lines)

    def __repr__(self) -> str:
        return (f"ReferenceTrajectory(n_steps={self.n_steps}, "
                f"total_time={self.total_time:.2f}s, "
                f"success={self.success})")


def test_reference_trajectory():
    """Unit tests for ReferenceTrajectory."""
    print("Testing ReferenceTrajectory...")

    # Test 1: Fixed-dt trajectory
    print("\n[Test 1] Fixed-dt trajectory")
    states = np.random.randn(50, 4)
    controls = np.random.randn(50, 2)
    ref = ReferenceTrajectory.from_fixed_dt(states, controls, dt=0.1)

    assert ref.n_steps == 50
    assert ref.total_time == 5.0
    assert np.allclose(ref.dt_array, 0.1)
    print(f"  ✓ Created {ref}")

    # Test 2: TEB trajectory with variable dt
    print("\n[Test 2] TEB trajectory with variable dt")
    dt_array = np.random.uniform(0.08, 0.30, 50)
    ref_teb = ReferenceTrajectory.from_teb_solution(
        states, controls, dt_array,
        metadata={"solver_iterations": 42}
    )

    assert ref_teb.n_steps == 50
    assert np.isclose(ref_teb.total_time, np.sum(dt_array))
    assert ref_teb.metadata["type"] == "teb"
    print(f"  ✓ Created {ref_teb}")

    # Test 3: Access methods
    print("\n[Test 3] Access methods")
    state_10 = ref.get_state_at_step(10)
    control_10 = ref.get_control_at_step(10)
    dt_10 = ref.get_dt_at_step(10)

    assert state_10.shape == (4,)
    assert control_10.shape == (2,)
    assert dt_10 == 0.1
    print(f"  ✓ Accessed step 10: state={state_10.shape}, control={control_10.shape}, dt={dt_10}")

    # Test 4: Reference window
    print("\n[Test 4] Reference window")
    states_win, controls_win, dt_win = ref.get_reference_window(start_step=10, horizon=20)

    assert states_win.shape == (20, 4)
    assert controls_win.shape == (20, 2)
    assert dt_win.shape == (20,)
    print(f"  ✓ Extracted window: {states_win.shape}, {controls_win.shape}, {dt_win.shape}")

    # Test 5: Committed maneuver with realistic steering pattern
    print("\n[Test 5] Maneuver analysis")
    # Create realistic parking maneuver: turn right, straighten, turn left
    states_maneuver = np.zeros((45, 4))
    controls_maneuver = np.zeros((45, 2))

    # Maneuver 1: Full right for 1.5s (15 steps × 0.1s)
    controls_maneuver[0:15, 0] = 0.52

    # Maneuver 2: Straighten for 0.5s (5 steps × 0.1s)
    controls_maneuver[15:20, 0] = 0.0

    # Maneuver 3: Left for 1.5s (15 steps × 0.1s)
    controls_maneuver[20:35, 0] = -0.45

    # Maneuver 4: Fine adjustment for 1.0s (10 steps × 0.1s)
    controls_maneuver[35:45, 0] = np.linspace(-0.10, 0.05, 10)

    ref_maneuver = ReferenceTrajectory.from_fixed_dt(states_maneuver, controls_maneuver, dt=0.1)
    maneuvers = ref_maneuver.analyze_maneuvers()

    print(f"  ✓ Found {len(maneuvers)} maneuvers:")
    for i, m in enumerate(maneuvers):
        print(f"    {i+1}. {m['description']}")

    # Test 6: Summary
    print("\n[Test 6] Summary")
    print(ref_maneuver.summary())

    print("\n✅ All tests passed!")


if __name__ == "__main__":
    test_reference_trajectory()
